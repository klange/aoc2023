def main():
    from aoc import lines
    from collections import deque

    let start
    for y in range(len(lines)):
        for x in range(len(lines[0])):
            if lines[y][x] == 'S':
                start = y,x
                break

    let my = len(lines) - 1
    let mx = len(lines[0]) - 1

    let next = deque()

    next.append((start, 0))

    let can_reach = set()
    let visited = set()

    while next:
        let p, c = next.popleft()
        let y, x = p

        if c == 64:
            can_reach.add(p)
            continue

        if (p,c) in visited:
            continue

        visited.add((p,c))

        if y > 0 and lines[y-1][x] != '#':  next.append(((y-1,x),c+1))
        if x > 0 and lines[y][x-1] != '#':  next.append(((y,x-1),c+1))
        if y < my and lines[y+1][x] != '#': next.append(((y+1,x),c+1))
        if x < mx and lines[y][x+1] != '#': next.append(((y,x+1),c+1))

    return len(can_reach)

def main2(amount):
    from aoc import lines
    from collections import deque
    from gc import collect

    let start
    for y in range(len(lines)):
        for x in range(len(lines[0])):
            if lines[y][x] == 'S':
                start = y,x
                break

    let ly = len(lines)
    let lx = len(lines[0])
    let ks = [None for n in range(lx)]
    let bs = [None for n in range(lx)]
    let possible = 0
    let nc, dc

    if True:
        let next = deque()
        let touched_recently = {start}
        let to_remove = deque()
        let last_refresh = 1
        let last_count = 0
        let last_deriv = 0
        let last_thing = [None for n in range(lx)]

        next.append((start, 0))

        def tryIt(y,x,c):
            let my, mx = y % ly, x % lx
            if lines[my][mx] == '#': return
            let f = (y,x)
            if f in touched_recently: return
            let n = f, c
            touched_recently.add(f)
            next.append(n)

        while next:
            let f = next.popleft()
            let p, c = f

            to_remove.append(f)
            while to_remove and to_remove[0][1] < c - 1:
                let t = to_remove.popleft()
                touched_recently.remove(t[0])

            if c != last_refresh:
                last_refresh = c
                if not c & 1:
                    if c > lx:
                        if last_thing[c%lx] is not None:
                            let x = c // lx
                            let t = (possible-last_count)-last_deriv
                            let b = (t - last_thing[c%lx]) // 2
                            let k = t - (b * x)
                            bs[c%lx] = b
                            ks[c%lx] = k
                        last_thing[c%lx] = (possible-last_count)-last_deriv
                    last_deriv = (possible-last_count)
                    last_count = possible
                    if all(x is not None for x in bs):
                        nc = c + 2
                        dc = last_deriv
                        print('patterns established by', nc)
                        break
                touched_recently = set(touched_recently)
                collect()

            if c & 1:
                possible += 1
            let y, x = p
            tryIt(y-1,x,c+1)
            tryIt(y,x-1,c+1)
            tryIt(y+1,x,c+1)
            tryIt(y,x+1,c+1)

    while nc <= amount + 1:
        possible += (dc += bs[nc%lx] * (nc // lx) + ks[nc%lx])
        nc += 2
    return possible


#print(main())
print(main2(26501365))
